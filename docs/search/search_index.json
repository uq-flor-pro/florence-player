{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DRAFT Florence Player by The Florence Project The finished player TODO Overview The Florence Project aimed to construct plans for a music player that would be suitable for families and Men's Sheds to build and simple for people living with dementia to use. Importantly, the player would have a backend accessible by web-browser over the local network to easily assign playlists to station buttons thus allowing people living with dementia and care-partners to easily individualise the music. We also wanted the possibility to customise the form of the player in a familiar or recognisable way as this would differ from person to person. We built upon free and open source software projects to do this, prioritising free and open source hardware, and now release our modifications under a permissive licence so that others can build and build further upon this player. Motivation In a systematic review of 4 studies on the effects of individualised music listening, Gariola et al concluded that the evidence, though limited, suggested positive impacts on agitation, anxiety, depression and emotion. The authors also noted that the outcomes were favourable compared to more resource-intensive interventions. Inspiration While designing our radio we were inspired and influenced by a number of other projects. We loved, and incorporated, the personalisation options of the The Relish Radio , the simplicity of the Simple Music Player , and the DIY nature of the Dementia-friendly music player . Notice Links to suppliers are used for reference and this project receives no financial or other benefit from any retailer listed. #legal TODO Warranty TODO Parts list 1 x Raspberry Pi 3B or 3B+ 2 x Speaker 3\" Diameter, 4 Ohm, 3 Watt 1 x Adafruit I2S 3 Watt Stereo Speaker Bonnet for Raspberry Pi 1 x Panel Mount 10K Dual Linear Potentiometer with On/Off Switch 1 x Black Metal Knob for 0.25\" shaft 1 x MCP3008 - 8-Channel 10-Bit ADC With SPI Interface 1 x RGB Diffused LED 2 x 2000 Ohm resistor 1 x 40 pin headers, pin (we only need 14 but get extra as you will probably want spares 1 ) 2 x 40 pin headers, socket 1 x Solderless breadboard for prototyping 8 x Machine Screw M3, 10mm length Philips 8 x Machine Hex Nut M3 1 x Raspberry Pi Mounting kit 7 x S3255 SPDT Momentary Push Button Microswitch 8 x 6mm diameter by 3mm height ferrite disk magnets Heat Shrink Tubing 1.2m length 3mm pre-shrunk, 1.5mm shrunk Hook-up stranded wire (22 AWG) Hook-up standard solid wire (22 AWG) 1 x 75 by 100mm 0.1\" Pitch Vero Board PCB Stripboard Solder Tools Soldering Iron Drill and 2mm drill bit Screwdriver Design Hardware Case Our first version was a 3D printed case with a single affordance: a clicky on/off and volume switch. Our first version In this version we wanted to include more options, especially the ability to skip tracks. However, since dementia is a progressive illness and over time someone with dementia might find it difficult to use certain features or find them confusing, we also wanted the case to be able to simplify over time. We cut and etched an extra piece of wood so that if the play/pause/skip buttons became confusing they could be removed and this wood piece glued on top of that position. Alternatively, if the stations were too complex a larger piece could be laser cut to cover this section. This means that the overall design remains the same but that any confusing elements can be removed over time. As some people living with dementia have reduced control of their hands, we chose switches that are easy to activate and spaced apart so that they can be individually pressed with a knuckle. Laser-cutting We were working on this player during a lockdown and had no physical access to a laser cutter. Instead we opted to do our best to make a schematic and have it professionally laser cut. We used the boxes.py generator for an electronics box with the following settings: The settings for the electronics box on boxes.py Your settings will depend on the thickness of your wood. 8 We then used Inkscape to add in the cutouts for the components and the etching. Our final versions can be found in the schematics directory of the repository. Software For this project we use Mopidy and based our player code on the Mopidy Pummeluff extension. Mopidy is an extensible music server written in Python and Mopidy Pummeluff is an extension for playing music by reading identification data from RFID tags. We chose Mopidy Pummeluff as it had a number of features: the ability to read uids from RFID tags a web interface to add RFID tag uids to a registry uses threading and could be modified to incorporate our changes was licensed under an appropriate licence One change we wanted to make was to use a 'clicky' on/off potentiometer instead of a rotary encoder for the volume as the on/off switch is a familiar affordance and a potentiometer provides accurate visual and tactile feedback (though the mark on the knob we have used is quite small and potentially hard to read). To make this change meant using an Analog to Digital Converter (ADC) to connect to the potentiometer as the GPIO pins on the pi are digital. The ADC we chose connects via Serial Peripheral Interface (SPI) as does the RFID reader. 7 We tried to get the RFID and ADC both working simultaneously with one using hardware SPI and the other software SPI. Unfortunately we couldn't and decided to focus on getting the base player working and try again later to incorporate RFID reading. Our software changes Registry Rather than create a new registry format for stations we decided it would be better to modify the RFID tag format to allow for the stations. To keep RFID tags a possibility later we modified the registry slightly so that a tag would by default be considered an RFID tag, but if this argument was false it would be handled as a station instead. This meant the Pummeluff web page and tornado web backend could also be modified rather simply. Web interface To change the web interface we added a new form for setting stations. This communicates with a modified web.py backend to handle setting stations and aliases. Aliases are convenient names for naming the playlists associated with a station. The form for assigning a tracklist to station 1 Stations We added a separate module containing a Station class and four subclasses representing the four station buttons. Build Assemble Speaker Bonnet We need to assemble the speaker bonnet as per Adafruit's instructions . This involves soldering the headers and speaker terminal blocks. RaspberryPi OS Warning Practice good security by keeping your Pi operating system up-to-date by regularly checking for updates, change the default password, and be careful running scripts and commands from the internet. We need to install the latest version of the Lite RaspberryPi OS (previously known as Raspbian). This tutorial from Random Nerd Tutorials explains the steps involved to flash the image to a microSD card with wireless credentials and SSH enabled. Make sure to change the default password in step 2.9. Power on the pi and check we can see connect to the Pi without knowing its ip by running the following command to SSH in: ssh pi@raspberrypi.local # or, if ssh tries to use ssh keys: # ssh pi@raspberrypi.local -o IdentitiesOnly=yes and if you get the result ssh: Could not resolve hostname raspberrypi.local: Name or service not known then try the following section. If you see a login prompt then log into the pi using the credentials you set and then skip the next section. (optional) If your raspberrypi is not accessible via raspberrypi.local In this case we need the ip of our device to log in via SSH. There are a few ways to get this. One way is to login to your router and look for the raspberry pi's connection. Otherwise this page has a number of alternatives. One you have the ip we can ssh into the pi. From there install avahi-daemon as show in this article . From now on we can access our Pi via this address rather than the ip. This will be useful to access the station management backend from different devices 11 . Update the OS First we check for updates and install any sudo apt update sudo apt upgrade Set up speakers In this step we wire up the speakers and connect them to the terminal blocks of the bonnet. The first half of this video shows the method we used. We can ignore the second half of the video as we are not attaching the speakers to a breadboard but to the Speaker Bonnet's terminal blocks. The method we use is: Cut the stranded wire to length #todo check length Strip all the ends of the wires Twist and tin each end Solder one end to the speakers as in the video Attach other end to speaker jumpers Install Speaker Bonnet Important Do this before install Mopidy or running the install script for the player. If done after this we had issues with sound. The first thing to do after updating the RaspberryPi OS needs to be installing the Speaker Bonnet. In our experience this needs to be done early on or we might have problems later. The instructions are on the Adafruit website . If you see a big red warning on that page regarding the Full version don't panic, we are using the Lite version of the RaspberryPi OS so this doesn't apply to us. The installer will offer to test the speakers, which hopefully will be successful. If not check the soldering of the bonnet, check the soldering of the speaker, or reinstall the bonnet software. Prototyping The breadboard schematic Next we build the player on a breadboard and check everything works. Tin the components We first tin the switches, the LED pins, and the potentiometer (including on/off switch) to make them easier to solder. To tin the switches we heat up the the normally open (NO) tabs of the switches and touch the solder to the heated component to flow some solder on, then do the same for the common (C) tab. 5 To tin the LED, the potentiometer, and the on/off switch we heat the wire and touch the solder to the heated wires to flow solder on. The potentiometer pins we use are the first three (shown in red in the next diagram) and the on/off switch (shown in blue) are the pair of pins at the end. The red pins are the potentiometer we use and the blue for the on/off switch Wires We use multi-stranded wire for most of the wire so that flexing it doesn't break the only thread. For mounting to the breadboard and later inserting into the header sockets it will be easier to have a single wire ends. We do this for one end of the following wires: 7 pairs for the switch leads 1 pair for the LED 5 wires total for the potentiometer and on/off switch combination The other end gets connected to the component. One switch down, six to go We add heatshrink to each to help prevent against short-circuits occuring. First cut the heatshrink, slide it over then solder and lastly use a lighter or heat gun to shrink the heatshrink. This video demostrates the whole process. Setup RaspberryPi OS and install the player Warning Be careful running commands from the internet Install Mopidy via their instructions Install pip for Python package management, and the requirements for the Spotify extension git python3-pip libSpotify12 python3-Spotify Install the Iris Mopidy web front end and the Spotify extension. sudo pip install mopidy-iris Mopidy-Spotify Enable SPI in rasp-config using this link if needed. Install the requirements for our player code sudo pip install spidev Give Mopidy access to SPI and GPIO groups sudo usermod -a -G spi,gpio mopidy Edit the Mopidy configuration and set Spotify credentials, local music location, etc. TODO sudo nano /etc/mopidy/mopidy.conf Install our modified player code. sudo cd /usr/src sudo git clone https://github.com/florenceproject/florenceplayer.git cd florenceplayer sudo python setup.py install Enable Mopidy to run at boot: sudo systemctl enable mopidy.service Start the Mopidy service now: sudo systemctl start mopidy.service Edit the boot file: sudo vim /boot/config.txt And add the following at the bottom to set the shutdown pin 15 : [shutdown] dtoverlay=gpio-shutdown,active_low=0 And save the file and reboot the pi sudo reboot Access the configuration page The web-server on the player is accessible via port 6680. Navigating to http://raspberrypi.local:6680 with a browser on the same network will hopefully show the Mopidy page with links to Iris and Florence. From here we can create playlists with Iris, and assign playlists to stations with Florence. Stripboard build Once we've confirmed everything works with a breadboard it's time to construct on the stripboard. The stripboard schematic Break the header pins into two 7 length pieces Quickly but carefully solder the switch wires to the header pins making sure the order on both are the same. We messed up twice but was happy with the third result. If this proves difficult skip the headers and mount the wire into the sockets directly. 2 The header pins are fragile: too much heat will melt the casing Not perfect but working. Next step is to shrink the heatshrink. We probably should have cut the single strand wire off and connected the headers to the stranded wire and they might have soldered better. Remove the IC from the breadboard using an IC extractor Cut header sockets into 8, 8, 7, 7, 7, 6, 4, 1, 1 lengths by counting out the number of sockets needed then removing the next pin with pliers, then cut the header sockets at the extracted pin 4 Break the 15 highlighted strips on the stripboad: the 7 length section for the station switches and 8 length section for the MCP3008. These are the gaps in the channels in the following schematic. We did this by carefully cutting with a craft knife but there are other methods 9 The 15 strips to cut Solder the components one by one Cut wire to length and solder it The soldered board. Note, this board uses a 2 socket header \u2014 not a single socket \u2014 on the top right but is otherwise based on the schematic. Rear view (mirrored left-right) Check the connections 3 Construction Mount the pi The mounting holes on the Pi 3B/3B+ form a rectangle 58mm wide by 49mm high 10 . Mount the pi so the top is just below the cutouts that will hold the triangles for the shelves. Account for the extra room taken up by the Speaker Bonnet and make sure to account for the extra distance taken up by the power cable at the bottom. 13 Important Check what cables need to be connected before assembling. In our case the usb micro cable can't be connected after assembling. Drill holes for the standoffs, then screw the standoffs in and mount the pi. Mounting the pi to the backplate Mount the speakers and potentiometer Screw the speakers in using four M3 screws and nuts. Mount the potentiometer in the front case and tighten with its nut. The potentiometer in the casing Sanding Sand the triangle tabs so that they fit nicely into the holes. Be gentle with them while they fit tightly as they might snap off as we found out first hand :(. A broken tab We had cut some extra lengths in case we needed to reinforce any corners and because there was extra room in the timber sheet we had lasercut. These pieces came in handy and we used one here as a cross-piece. Improvised cross-piece We also found we needed to sand in between the tabs of the sides pieces to get a good fit 14 . We wrapped a 13cm by 4mm long piece in 400 grit sandpaper to form a nice tool for this. Gluing up When it was time to glue we used the method in this video . Future ideas In the wild it A button to update the radio at a convenient time. Made the led stay on while the pi is on. Mistakes Here's a few of the mistakes we made in building the player. We broke a tab doing a test assembly We're still annoyed about that (see above). Stealing the Speaker Bonnet's I2S pin to use as a station switch We were wondering why audio was working without the extension but not when it was running. The gstreamer output worked but the player didn't. It turned out that one of the station pins had been set up to use one of the I2S pins that the Pi uses to communicate with the Speaker Bonnet. The Speaker Bonnet exposes this pin even though it's in use by the bonnet. Changing this pin to a free pin restored audio. The pi-rc522 library that Pummeluff uses needs the pinmode set to Board The pins on a raspberry pi can be referenced numerically in multiple ways. This is known as pinmode. To use the RFID reading capabilities of Pummeluff at the same time it is necessary to change the pinmode to Board from BCM in the gpio_handler and mcp_watcher files otherwise conflicting modes will cause an error. 12 This stumped us for a while. Since we aren't using this the RFID reader at the moment, we have commented out the sections where it this code gets called and used BCM mode. Notes Speaker Bonnet We had some issues getting the speaker bonnet set up originally. Adafruit's debugging suggestions generally involve reflashing the OS and reinstalling the speaker bonnet code and checking soldering. Both can be frustrating, but the first is one of the reasons we install the speaker bonnet so early in the process now. This way if we need to reinstall there's less to do. Wireless drops out under load When connected using wifi and performing updates or when transferring files using scp we often found the network connection would drop out for a few minutes. This link seems to refer to the issue. Throttling the connection using wondershaper didn't seem to help. This only happened over wifi. In building our prototype we had to do this a few times and still didn't get it perfect. However we think it's worthwhile doing as it makes the final version much cleaner and easier to work with. \u21a9 We work quickly because the plastic frame on the headers will easily melt if we linger on a pin too long. To solder, we used this method https://www.youtube.com/watch?v=IkjMK26ROcM \u21a9 We checked each joint with a multimeter and also tested portions of of the board we know should be connected. There should be a 0 Ohm potential between any two connected points, and a large resistance between unconnected points. \u21a9 Wirecutters work well. \u21a9 https://www.youtube.com/watch?v=pf_Mngbx32w is a good example of this soldering a similiar component to the switches we used. \u21a9 https://www.festi.info/boxes.py/ElectronicsBox?language=en \u21a9 We originally chose an ADC that used SPI not I2C because we wanted to keep GPIO 3 free. This is because pin 3 can be used to start up the pi from the shutdown state by connecting it to ground. We also want to shut the pi down using a GPIO signal but didn't realise until later that the pi can be shutdown by other GPIO pins by specifying them in /boot/config.txt. See this file in the section named gpio-shutdown for details. Since it is possible to specify this other pin for shutdown, using a I2C ADC might work well as it would free up the hardware SPI for the RFID reader. \u21a9 If you use this generator with a thick piece of wood and the tabs on the triangles disappear you might need to increase the triangle measurement to compensate. \u21a9 https://electronics.stackexchange.com/questions/94659/how-to-cut-the-tracks-of-a-stripboard \u21a9 https://datasheets.raspberrypi.com/rpi3/raspberry-pi-3-b-plus-mechanical-drawing.pdf \u21a9 Alternatively we can set up a static ip on the player but this is not perfect as another device might take the player's lease, perhaps while the player is off. \u21a9 See this bug report for more \u21a9 We placed our pi too low and needed to use a right-angle usb cord so as to fit in the gap between the bottom of the pi and the bottom plate. \u21a9 There is a burn variable in festi-boxes that can help with the fit, but will require a few test cuts on your laser-cutter. \u21a9 Explanation here \u21a9","title":"Florence Player Build Instructions"},{"location":"#draft-florence-player","text":"by The Florence Project The finished player TODO","title":"DRAFT Florence Player"},{"location":"#overview","text":"The Florence Project aimed to construct plans for a music player that would be suitable for families and Men's Sheds to build and simple for people living with dementia to use. Importantly, the player would have a backend accessible by web-browser over the local network to easily assign playlists to station buttons thus allowing people living with dementia and care-partners to easily individualise the music. We also wanted the possibility to customise the form of the player in a familiar or recognisable way as this would differ from person to person. We built upon free and open source software projects to do this, prioritising free and open source hardware, and now release our modifications under a permissive licence so that others can build and build further upon this player.","title":"Overview"},{"location":"#motivation","text":"In a systematic review of 4 studies on the effects of individualised music listening, Gariola et al concluded that the evidence, though limited, suggested positive impacts on agitation, anxiety, depression and emotion. The authors also noted that the outcomes were favourable compared to more resource-intensive interventions.","title":"Motivation"},{"location":"#inspiration","text":"While designing our radio we were inspired and influenced by a number of other projects. We loved, and incorporated, the personalisation options of the The Relish Radio , the simplicity of the Simple Music Player , and the DIY nature of the Dementia-friendly music player .","title":"Inspiration"},{"location":"#notice","text":"Links to suppliers are used for reference and this project receives no financial or other benefit from any retailer listed. #legal TODO","title":"Notice"},{"location":"#warranty","text":"TODO","title":"Warranty"},{"location":"#parts-list","text":"1 x Raspberry Pi 3B or 3B+ 2 x Speaker 3\" Diameter, 4 Ohm, 3 Watt 1 x Adafruit I2S 3 Watt Stereo Speaker Bonnet for Raspberry Pi 1 x Panel Mount 10K Dual Linear Potentiometer with On/Off Switch 1 x Black Metal Knob for 0.25\" shaft 1 x MCP3008 - 8-Channel 10-Bit ADC With SPI Interface 1 x RGB Diffused LED 2 x 2000 Ohm resistor 1 x 40 pin headers, pin (we only need 14 but get extra as you will probably want spares 1 ) 2 x 40 pin headers, socket 1 x Solderless breadboard for prototyping 8 x Machine Screw M3, 10mm length Philips 8 x Machine Hex Nut M3 1 x Raspberry Pi Mounting kit 7 x S3255 SPDT Momentary Push Button Microswitch 8 x 6mm diameter by 3mm height ferrite disk magnets Heat Shrink Tubing 1.2m length 3mm pre-shrunk, 1.5mm shrunk Hook-up stranded wire (22 AWG) Hook-up standard solid wire (22 AWG) 1 x 75 by 100mm 0.1\" Pitch Vero Board PCB Stripboard Solder","title":"Parts list"},{"location":"#tools","text":"Soldering Iron Drill and 2mm drill bit Screwdriver","title":"Tools"},{"location":"#design","text":"","title":"Design"},{"location":"#hardware","text":"","title":"Hardware"},{"location":"#case","text":"Our first version was a 3D printed case with a single affordance: a clicky on/off and volume switch. Our first version In this version we wanted to include more options, especially the ability to skip tracks. However, since dementia is a progressive illness and over time someone with dementia might find it difficult to use certain features or find them confusing, we also wanted the case to be able to simplify over time. We cut and etched an extra piece of wood so that if the play/pause/skip buttons became confusing they could be removed and this wood piece glued on top of that position. Alternatively, if the stations were too complex a larger piece could be laser cut to cover this section. This means that the overall design remains the same but that any confusing elements can be removed over time. As some people living with dementia have reduced control of their hands, we chose switches that are easy to activate and spaced apart so that they can be individually pressed with a knuckle.","title":"Case"},{"location":"#laser-cutting","text":"We were working on this player during a lockdown and had no physical access to a laser cutter. Instead we opted to do our best to make a schematic and have it professionally laser cut. We used the boxes.py generator for an electronics box with the following settings: The settings for the electronics box on boxes.py Your settings will depend on the thickness of your wood. 8 We then used Inkscape to add in the cutouts for the components and the etching. Our final versions can be found in the schematics directory of the repository.","title":"Laser-cutting"},{"location":"#software","text":"For this project we use Mopidy and based our player code on the Mopidy Pummeluff extension. Mopidy is an extensible music server written in Python and Mopidy Pummeluff is an extension for playing music by reading identification data from RFID tags. We chose Mopidy Pummeluff as it had a number of features: the ability to read uids from RFID tags a web interface to add RFID tag uids to a registry uses threading and could be modified to incorporate our changes was licensed under an appropriate licence One change we wanted to make was to use a 'clicky' on/off potentiometer instead of a rotary encoder for the volume as the on/off switch is a familiar affordance and a potentiometer provides accurate visual and tactile feedback (though the mark on the knob we have used is quite small and potentially hard to read). To make this change meant using an Analog to Digital Converter (ADC) to connect to the potentiometer as the GPIO pins on the pi are digital. The ADC we chose connects via Serial Peripheral Interface (SPI) as does the RFID reader. 7 We tried to get the RFID and ADC both working simultaneously with one using hardware SPI and the other software SPI. Unfortunately we couldn't and decided to focus on getting the base player working and try again later to incorporate RFID reading.","title":"Software"},{"location":"#our-software-changes","text":"","title":"Our software changes"},{"location":"#registry","text":"Rather than create a new registry format for stations we decided it would be better to modify the RFID tag format to allow for the stations. To keep RFID tags a possibility later we modified the registry slightly so that a tag would by default be considered an RFID tag, but if this argument was false it would be handled as a station instead. This meant the Pummeluff web page and tornado web backend could also be modified rather simply.","title":"Registry"},{"location":"#web-interface","text":"To change the web interface we added a new form for setting stations. This communicates with a modified web.py backend to handle setting stations and aliases. Aliases are convenient names for naming the playlists associated with a station. The form for assigning a tracklist to station 1","title":"Web interface"},{"location":"#stations","text":"We added a separate module containing a Station class and four subclasses representing the four station buttons.","title":"Stations"},{"location":"#build","text":"","title":"Build"},{"location":"#assemble-speaker-bonnet","text":"We need to assemble the speaker bonnet as per Adafruit's instructions . This involves soldering the headers and speaker terminal blocks.","title":"Assemble Speaker Bonnet"},{"location":"#raspberrypi-os","text":"Warning Practice good security by keeping your Pi operating system up-to-date by regularly checking for updates, change the default password, and be careful running scripts and commands from the internet. We need to install the latest version of the Lite RaspberryPi OS (previously known as Raspbian). This tutorial from Random Nerd Tutorials explains the steps involved to flash the image to a microSD card with wireless credentials and SSH enabled. Make sure to change the default password in step 2.9. Power on the pi and check we can see connect to the Pi without knowing its ip by running the following command to SSH in: ssh pi@raspberrypi.local # or, if ssh tries to use ssh keys: # ssh pi@raspberrypi.local -o IdentitiesOnly=yes and if you get the result ssh: Could not resolve hostname raspberrypi.local: Name or service not known then try the following section. If you see a login prompt then log into the pi using the credentials you set and then skip the next section.","title":"RaspberryPi OS"},{"location":"#optional-if-your-raspberrypi-is-not-accessible-via-raspberrypilocal","text":"In this case we need the ip of our device to log in via SSH. There are a few ways to get this. One way is to login to your router and look for the raspberry pi's connection. Otherwise this page has a number of alternatives. One you have the ip we can ssh into the pi. From there install avahi-daemon as show in this article . From now on we can access our Pi via this address rather than the ip. This will be useful to access the station management backend from different devices 11 .","title":"(optional) If your raspberrypi is not  accessible via raspberrypi.local"},{"location":"#update-the-os","text":"First we check for updates and install any sudo apt update sudo apt upgrade","title":"Update the OS"},{"location":"#set-up-speakers","text":"In this step we wire up the speakers and connect them to the terminal blocks of the bonnet. The first half of this video shows the method we used. We can ignore the second half of the video as we are not attaching the speakers to a breadboard but to the Speaker Bonnet's terminal blocks. The method we use is: Cut the stranded wire to length #todo check length Strip all the ends of the wires Twist and tin each end Solder one end to the speakers as in the video Attach other end to speaker jumpers","title":"Set up speakers"},{"location":"#install-speaker-bonnet","text":"Important Do this before install Mopidy or running the install script for the player. If done after this we had issues with sound. The first thing to do after updating the RaspberryPi OS needs to be installing the Speaker Bonnet. In our experience this needs to be done early on or we might have problems later. The instructions are on the Adafruit website . If you see a big red warning on that page regarding the Full version don't panic, we are using the Lite version of the RaspberryPi OS so this doesn't apply to us. The installer will offer to test the speakers, which hopefully will be successful. If not check the soldering of the bonnet, check the soldering of the speaker, or reinstall the bonnet software.","title":"Install Speaker Bonnet"},{"location":"#prototyping","text":"The breadboard schematic Next we build the player on a breadboard and check everything works.","title":"Prototyping"},{"location":"#tin-the-components","text":"We first tin the switches, the LED pins, and the potentiometer (including on/off switch) to make them easier to solder. To tin the switches we heat up the the normally open (NO) tabs of the switches and touch the solder to the heated component to flow some solder on, then do the same for the common (C) tab. 5 To tin the LED, the potentiometer, and the on/off switch we heat the wire and touch the solder to the heated wires to flow solder on. The potentiometer pins we use are the first three (shown in red in the next diagram) and the on/off switch (shown in blue) are the pair of pins at the end. The red pins are the potentiometer we use and the blue for the on/off switch","title":"Tin the components"},{"location":"#wires","text":"We use multi-stranded wire for most of the wire so that flexing it doesn't break the only thread. For mounting to the breadboard and later inserting into the header sockets it will be easier to have a single wire ends. We do this for one end of the following wires: 7 pairs for the switch leads 1 pair for the LED 5 wires total for the potentiometer and on/off switch combination The other end gets connected to the component. One switch down, six to go We add heatshrink to each to help prevent against short-circuits occuring. First cut the heatshrink, slide it over then solder and lastly use a lighter or heat gun to shrink the heatshrink. This video demostrates the whole process.","title":"Wires"},{"location":"#setup-raspberrypi-os-and-install-the-player","text":"Warning Be careful running commands from the internet Install Mopidy via their instructions Install pip for Python package management, and the requirements for the Spotify extension git python3-pip libSpotify12 python3-Spotify Install the Iris Mopidy web front end and the Spotify extension. sudo pip install mopidy-iris Mopidy-Spotify Enable SPI in rasp-config using this link if needed. Install the requirements for our player code sudo pip install spidev Give Mopidy access to SPI and GPIO groups sudo usermod -a -G spi,gpio mopidy Edit the Mopidy configuration and set Spotify credentials, local music location, etc. TODO sudo nano /etc/mopidy/mopidy.conf Install our modified player code. sudo cd /usr/src sudo git clone https://github.com/florenceproject/florenceplayer.git cd florenceplayer sudo python setup.py install Enable Mopidy to run at boot: sudo systemctl enable mopidy.service Start the Mopidy service now: sudo systemctl start mopidy.service Edit the boot file: sudo vim /boot/config.txt And add the following at the bottom to set the shutdown pin 15 : [shutdown] dtoverlay=gpio-shutdown,active_low=0 And save the file and reboot the pi sudo reboot","title":"Setup RaspberryPi OS and install the player"},{"location":"#access-the-configuration-page","text":"The web-server on the player is accessible via port 6680. Navigating to http://raspberrypi.local:6680 with a browser on the same network will hopefully show the Mopidy page with links to Iris and Florence. From here we can create playlists with Iris, and assign playlists to stations with Florence.","title":"Access the configuration page"},{"location":"#stripboard-build","text":"Once we've confirmed everything works with a breadboard it's time to construct on the stripboard. The stripboard schematic Break the header pins into two 7 length pieces Quickly but carefully solder the switch wires to the header pins making sure the order on both are the same. We messed up twice but was happy with the third result. If this proves difficult skip the headers and mount the wire into the sockets directly. 2 The header pins are fragile: too much heat will melt the casing Not perfect but working. Next step is to shrink the heatshrink. We probably should have cut the single strand wire off and connected the headers to the stranded wire and they might have soldered better. Remove the IC from the breadboard using an IC extractor Cut header sockets into 8, 8, 7, 7, 7, 6, 4, 1, 1 lengths by counting out the number of sockets needed then removing the next pin with pliers, then cut the header sockets at the extracted pin 4 Break the 15 highlighted strips on the stripboad: the 7 length section for the station switches and 8 length section for the MCP3008. These are the gaps in the channels in the following schematic. We did this by carefully cutting with a craft knife but there are other methods 9 The 15 strips to cut Solder the components one by one Cut wire to length and solder it The soldered board. Note, this board uses a 2 socket header \u2014 not a single socket \u2014 on the top right but is otherwise based on the schematic. Rear view (mirrored left-right) Check the connections 3","title":"Stripboard build"},{"location":"#construction","text":"","title":"Construction"},{"location":"#mount-the-pi","text":"The mounting holes on the Pi 3B/3B+ form a rectangle 58mm wide by 49mm high 10 . Mount the pi so the top is just below the cutouts that will hold the triangles for the shelves. Account for the extra room taken up by the Speaker Bonnet and make sure to account for the extra distance taken up by the power cable at the bottom. 13 Important Check what cables need to be connected before assembling. In our case the usb micro cable can't be connected after assembling. Drill holes for the standoffs, then screw the standoffs in and mount the pi. Mounting the pi to the backplate","title":"Mount the pi"},{"location":"#mount-the-speakers-and-potentiometer","text":"Screw the speakers in using four M3 screws and nuts. Mount the potentiometer in the front case and tighten with its nut. The potentiometer in the casing","title":"Mount the speakers and potentiometer"},{"location":"#sanding","text":"Sand the triangle tabs so that they fit nicely into the holes. Be gentle with them while they fit tightly as they might snap off as we found out first hand :(. A broken tab We had cut some extra lengths in case we needed to reinforce any corners and because there was extra room in the timber sheet we had lasercut. These pieces came in handy and we used one here as a cross-piece. Improvised cross-piece We also found we needed to sand in between the tabs of the sides pieces to get a good fit 14 . We wrapped a 13cm by 4mm long piece in 400 grit sandpaper to form a nice tool for this.","title":"Sanding"},{"location":"#gluing-up","text":"When it was time to glue we used the method in this video .","title":"Gluing up"},{"location":"#future-ideas","text":"In the wild it A button to update the radio at a convenient time. Made the led stay on while the pi is on.","title":"Future ideas"},{"location":"#mistakes","text":"Here's a few of the mistakes we made in building the player.","title":"Mistakes"},{"location":"#we-broke-a-tab-doing-a-test-assembly","text":"We're still annoyed about that (see above).","title":"We broke a tab doing a test assembly"},{"location":"#stealing-the-speaker-bonnets-i2s-pin-to-use-as-a-station-switch","text":"We were wondering why audio was working without the extension but not when it was running. The gstreamer output worked but the player didn't. It turned out that one of the station pins had been set up to use one of the I2S pins that the Pi uses to communicate with the Speaker Bonnet. The Speaker Bonnet exposes this pin even though it's in use by the bonnet. Changing this pin to a free pin restored audio.","title":"Stealing the Speaker Bonnet's I2S pin to use as a station switch"},{"location":"#the-pi-rc522-library-that-pummeluff-uses-needs-the-pinmode-set-to-board","text":"The pins on a raspberry pi can be referenced numerically in multiple ways. This is known as pinmode. To use the RFID reading capabilities of Pummeluff at the same time it is necessary to change the pinmode to Board from BCM in the gpio_handler and mcp_watcher files otherwise conflicting modes will cause an error. 12 This stumped us for a while. Since we aren't using this the RFID reader at the moment, we have commented out the sections where it this code gets called and used BCM mode.","title":"The pi-rc522 library that Pummeluff uses needs the pinmode set to Board"},{"location":"#_1","text":"","title":""},{"location":"#notes","text":"","title":"Notes"},{"location":"#speaker-bonnet","text":"We had some issues getting the speaker bonnet set up originally. Adafruit's debugging suggestions generally involve reflashing the OS and reinstalling the speaker bonnet code and checking soldering. Both can be frustrating, but the first is one of the reasons we install the speaker bonnet so early in the process now. This way if we need to reinstall there's less to do.","title":"Speaker Bonnet"},{"location":"#wireless-drops-out-under-load","text":"When connected using wifi and performing updates or when transferring files using scp we often found the network connection would drop out for a few minutes. This link seems to refer to the issue. Throttling the connection using wondershaper didn't seem to help. This only happened over wifi. In building our prototype we had to do this a few times and still didn't get it perfect. However we think it's worthwhile doing as it makes the final version much cleaner and easier to work with. \u21a9 We work quickly because the plastic frame on the headers will easily melt if we linger on a pin too long. To solder, we used this method https://www.youtube.com/watch?v=IkjMK26ROcM \u21a9 We checked each joint with a multimeter and also tested portions of of the board we know should be connected. There should be a 0 Ohm potential between any two connected points, and a large resistance between unconnected points. \u21a9 Wirecutters work well. \u21a9 https://www.youtube.com/watch?v=pf_Mngbx32w is a good example of this soldering a similiar component to the switches we used. \u21a9 https://www.festi.info/boxes.py/ElectronicsBox?language=en \u21a9 We originally chose an ADC that used SPI not I2C because we wanted to keep GPIO 3 free. This is because pin 3 can be used to start up the pi from the shutdown state by connecting it to ground. We also want to shut the pi down using a GPIO signal but didn't realise until later that the pi can be shutdown by other GPIO pins by specifying them in /boot/config.txt. See this file in the section named gpio-shutdown for details. Since it is possible to specify this other pin for shutdown, using a I2C ADC might work well as it would free up the hardware SPI for the RFID reader. \u21a9 If you use this generator with a thick piece of wood and the tabs on the triangles disappear you might need to increase the triangle measurement to compensate. \u21a9 https://electronics.stackexchange.com/questions/94659/how-to-cut-the-tracks-of-a-stripboard \u21a9 https://datasheets.raspberrypi.com/rpi3/raspberry-pi-3-b-plus-mechanical-drawing.pdf \u21a9 Alternatively we can set up a static ip on the player but this is not perfect as another device might take the player's lease, perhaps while the player is off. \u21a9 See this bug report for more \u21a9 We placed our pi too low and needed to use a right-angle usb cord so as to fit in the gap between the bottom of the pi and the bottom plate. \u21a9 There is a burn variable in festi-boxes that can help with the fit, but will require a few test cuts on your laser-cutter. \u21a9 Explanation here \u21a9","title":"Wireless drops out under load"}]}